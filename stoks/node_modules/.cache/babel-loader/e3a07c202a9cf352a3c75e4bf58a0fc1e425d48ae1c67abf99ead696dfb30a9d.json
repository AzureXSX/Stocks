{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// **Github:** https://github.com/fidm/quic\n//\n// **License:** MIT\nconst util_1 = require(\"util\");\nconst error_1 = require(\"./error\");\nconst protocol_1 = require(\"./protocol\");\nconst common_1 = require(\"./common\");\n// Frame Types\n// | Type­field value | Control Frame­type |\n//\n// ----- Regular Frame Types\n// | 00000000B (0x00) | PADDING |\n// | 00000001B (0x01) | RST_STREAM |\n// | 00000010B (0x02) | CONNECTION_CLOSE |\n// | 00000011B (0x03) | GOAWAY |\n// | 00000100B (0x04) | WINDOW_UPDATE |\n// | 00000101B (0x05) | BLOCKED |\n// | 00000110B (0x06) | STOP_WAITING |\n// | 00000111B (0x07) | PING |\n//\n// ----- Special Frame Types\n// | 001xxxxxB | CONGESTION_FEEDBACK |\n// | 01ntllmmB | ACK |\n// | 1fdooossB | STREAM |\n// -----\nfunction isCongestionType(flag) {\n  return (flag & 0b11100000) === 0b00100000;\n}\nexports.isCongestionType = isCongestionType;\nfunction isACKType(flag) {\n  return (flag & 0b11000000) === 0b01000000;\n}\nexports.isACKType = isACKType;\nfunction isStreamType(flag) {\n  return flag > 0b10000000;\n}\nexports.isStreamType = isStreamType;\nfunction parseFrame(bufv, headerPacketNumber) {\n  bufv.walk(0); // align start and end\n  const type = bufv.buf.readUInt8(bufv.start);\n  if (type >= 128) {\n    return StreamFrame.fromBuffer(bufv);\n  }\n  if (type >= 64) {\n    return AckFrame.fromBuffer(bufv);\n  }\n  if (type >= 32) {\n    return CongestionFeedbackFrame.fromBuffer(bufv);\n  }\n  switch (type) {\n    case 0:\n      return PaddingFrame.fromBuffer(bufv);\n    case 1:\n      return RstStreamFrame.fromBuffer(bufv);\n    case 2:\n      return ConnectionCloseFrame.fromBuffer(bufv);\n    case 3:\n      return GoAwayFrame.fromBuffer(bufv);\n    case 4:\n      return WindowUpdateFrame.fromBuffer(bufv);\n    case 5:\n      return BlockedFrame.fromBuffer(bufv);\n    case 6:\n      return StopWaitingFrame.fromBuffer(bufv, headerPacketNumber);\n    case 7:\n      return PingFrame.fromBuffer(bufv);\n    default:\n      throw new error_1.QuicError('QUIC_INVALID_FRAME_DATA');\n  }\n}\nexports.parseFrame = parseFrame;\n/** Frame representing a QUIC frame. */\nclass Frame {\n  static fromBuffer(_bufv, _headerPacketNumber) {\n    throw new Error(`class method \"fromBuffer\" is not implemented`);\n  }\n  constructor(type, name) {\n    this.type = type;\n    this.name = name;\n  }\n  valueOf() {\n    return {\n      name: this.name,\n      type: this.type\n    };\n  }\n  toString() {\n    return JSON.stringify(this.valueOf());\n  }\n  isRetransmittable() {\n    return this.name !== 'ACK' && this.name !== 'STOP_WAITING';\n  }\n  [util_1.inspect.custom](_depth, _options) {\n    return `<${this.constructor.name} ${this.toString()}>`;\n  }\n}\nexports.Frame = Frame;\n/** StreamFrame representing a QUIC STREAM frame. */\nclass StreamFrame extends Frame {\n  // STREAM Frame\n  //\n  // The STREAM frame is used to both implicitly create a stream and to send data on it, and is as follows:\n  // --- src\n  //      0        1       …               SLEN\n  // +--------+--------+--------+--------+--------+\n  // |Type (8)| Stream ID (8, 16, 24, or 32 bits) |\n  // |        |    (Variable length SLEN bytes)   |\n  // +--------+--------+--------+--------+--------+\n  //\n  //   SLEN+1  SLEN+2     …                                         SLEN+OLEN\n  // +--------+--------+--------+--------+--------+--------+--------+--------+\n  // |   Offset (0, 16, 24, 32, 40, 48, 56, or 64 bits) (variable length)    |\n  // |                    (Variable length: OLEN  bytes)                     |\n  // +--------+--------+--------+--------+--------+--------+--------+--------+\n  //\n  //   SLEN+OLEN+1   SLEN+OLEN+2\n  // +-------------+-------------+\n  // | Data length (0 or 16 bits)|\n  // |  Optional(maybe 0 bytes)  |\n  // +------------+--------------+\n  // ---\n  //\n  // The fields in the STREAM frame header are as follows:\n  // * Frame Type: The Frame Type byte is an 8-bit value containing various flags (1fdooossB):\n  //   - The leftmost bit must be set to 1 indicating that this is a STREAM frame.\n  //   - The 'f' bit is the FIN bit. When set to 1, this bit indicates the sender is done\n  //     sending on this stream and wishes to \"half-close\" (described in more detail later.)\n  //   - The 'd' bit indicates whether a Data Length is present in the STREAM header. When set to 0,\n  //     this field indicates that the STREAM frame extends to the end of the Packet.\n  //   - The next three 'ooo' bits encode the length of the Offset header field as\n  //     0, 16, 24, 32, 40, 48, 56, or 64 bits long.\n  //   - The next two 'ss' bits encode the length of the Stream ID header field as 8, 16, 24, or 32 bits long.\n  // * Stream ID: A variable-sized unsigned ID unique to this stream.\n  // * Offset: A variable-sized unsigned number specifying the byte offset in the stream for this block of data.\n  // * Data length: An optional 16-bit unsigned number specifying the length of the data in this stream frame.\n  //     The option to omit the length should only be used when the packet is a \"full-sized\" Packet,\n  //     to avoid the risk of corruption via padding.\n  //\n  // A stream frame must always have either non-zero data length or the FIN bit set.\n  static fromBuffer(bufv) {\n    bufv.walk(1);\n    const type = bufv.buf[bufv.start];\n    if (!isStreamType(type)) {\n      throw new error_1.QuicError('QUIC_INVALID_STREAM_DATA');\n    }\n    const isFIN = (type & 0b1000000) > 0;\n    const streamID = protocol_1.StreamID.fromBuffer(bufv, protocol_1.StreamID.flagToByteLen(type & 0b11));\n    const offset = protocol_1.Offset.fromBuffer(bufv, protocol_1.Offset.flagToByteLen((type & 0b11100) >> 2));\n    let data = null;\n    if ((type & 0b100000) > 0) {\n      // a Data Length is present in the STREAM header\n      bufv.walk(2);\n      if (bufv.isOutside()) {\n        throw new error_1.QuicError('QUIC_INVALID_STREAM_DATA');\n      }\n      const len = bufv.buf.readUInt16BE(bufv.start);\n      if (len > 0) {\n        bufv.walk(len);\n        if (bufv.isOutside()) {\n          throw new error_1.QuicError('QUIC_INVALID_STREAM_DATA');\n        }\n        data = Buffer.allocUnsafe(len); // should copy to release socket buffer\n        bufv.buf.copy(data, 0, bufv.start, bufv.end);\n      }\n    } else if (bufv.length > bufv.end) {\n      // the STREAM frame extends to the end of the Packet.\n      bufv.walk(bufv.length - bufv.end);\n      data = Buffer.allocUnsafe(bufv.end - bufv.start); // should copy to release socket buffer\n      bufv.buf.copy(data, 0, bufv.start, bufv.end);\n    }\n    const frame = new StreamFrame(streamID, offset, isFIN);\n    frame.setData(data);\n    frame.type = type;\n    return frame;\n  }\n  constructor(streamID, offset, isFIN = false) {\n    super(0b10000000, 'STREAM');\n    this.streamID = streamID;\n    this.offset = offset;\n    this.isFIN = isFIN;\n    this.data = null;\n  }\n  setData(data) {\n    if (data != null && data.length === 0) {\n      data = null;\n    }\n    if (data == null) {\n      this.isFIN = true;\n    }\n    this.data = data;\n    return this;\n  }\n  valueOf() {\n    return {\n      name: this.name,\n      type: this.type,\n      isFIN: this.isFIN,\n      streamID: this.streamID.valueOf(),\n      offset: this.offset.valueOf(),\n      data: this.data\n    };\n  }\n  headerLen(hasDataLen) {\n    const len = hasDataLen ? 2 : 0;\n    return 1 + this.streamID.byteLen() + this.offset.byteLen() + len;\n  }\n  byteLen() {\n    const dataLen = this.data != null ? this.data.length : 0;\n    return this.headerLen(dataLen > 0) + dataLen;\n  }\n  writeTo(bufv) {\n    if (this.isFIN) {\n      this.type |= 0b1000000;\n    }\n    if (this.data != null) {\n      this.type |= 0b00100000;\n    }\n    this.type |= this.offset.flagBits() << 2;\n    this.type |= this.streamID.flagBits();\n    bufv.walk(1);\n    bufv.buf.writeUInt8(this.type, bufv.start);\n    this.streamID.writeTo(bufv);\n    this.offset.writeTo(bufv);\n    if (this.data != null) {\n      bufv.walk(2);\n      bufv.buf.writeUInt16BE(this.data.length, bufv.start);\n      bufv.walk(this.data.length);\n      this.data.copy(bufv.buf, bufv.start, 0, this.data.length);\n    }\n    return bufv;\n  }\n}\nexports.StreamFrame = StreamFrame;\n/** AckRange representing a range for ACK. */\nclass AckRange {\n  constructor(firstPacketNumberValue, lastPacketNumberValue) {\n    this.last = lastPacketNumberValue; // last >= first\n    this.first = firstPacketNumberValue; // PacketNumber value\n  }\n  len() {\n    return this.last - this.first + 1;\n  }\n}\nexports.AckRange = AckRange;\n/** AckFrame representing a QUIC ACK frame. */\nclass AckFrame extends Frame {\n  // ACK Frame\n  //\n  // Section Offsets\n  // 0: Start of the ack frame.\n  // T: Byte offset of the start of the timestamp section.\n  // A: Byte offset of the start of the ack block section.\n  // N: Length in bytes of the largest acked.\n  //\n  // --- src\n  //      0                            1  => N                     N+1 => A(aka N + 3)\n  // +---------+-------------------------------------------------+--------+--------+\n  // |   Type  |                   Largest Acked                 |  Largest Acked  |\n  // |   (8)   |    (8, 16, 32, or 48 bits, determined by ll)    | Delta Time (16) |\n  // |01nullmm |                                                 |                 |\n  // +---------+-------------------------------------------------+--------+--------+\n  //\n  //      A             A + 1  ==>  A + N\n  // +--------+----------------------------------------+\n  // | Number |             First Ack                  |\n  // |Blocks-1|           Block Length                 |\n  // | (opt)  |(8, 16, 32 or 48 bits, determined by mm)|\n  // +--------+----------------------------------------+\n  //\n  //   A + N + 1                A + N + 2  ==>  T(aka A + 2N + 1)\n  // +------------+-------------------------------------------------+\n  // | Gap to next|              Ack Block Length                   |\n  // | Block (8)  |   (8, 16, 32, or 48 bits, determined by mm)     |\n  // | (Repeats)  |       (repeats Number Ranges times)             |\n  // +------------+-------------------------------------------------+\n  //\n  //      T        T+1             T+2                 (Repeated Num Timestamps)\n  // +----------+--------+---------------------+ ...  --------+------------------+\n  // |   Num    | Delta  |     Time Since      |     | Delta  |       Time       |\n  // |Timestamps|Largest |    Largest Acked    |     |Largest |  Since Previous  |\n  // |   (8)    | Acked  |      (32 bits)      |     | Acked  |Timestamp(16 bits)|\n  // +----------+--------+---------------------+     +--------+------------------+\n  // ---\n  //\n  // The fields in the ACK frame are as follows:\n  // * Frame Type: The Frame Type byte is an 8-bit value containing various flags (01nullmmB).\n  //   - The first two bits must be set to 01 indicating that this is an ACK frame.\n  //   - The 'n' bit indicates whether the frame has more than 1 ack range.\n  //   - The 'u' bit is unused.\n  //   - The two 'll' bits encode the length of the Largest Observed field as 1, 2, 4, or 6 bytes long.\n  //   - The two 'mm' bits encode the length of the Missing Packet Sequence Number Delta field as\n  //     1, 2, 4, or 6 bytes long.\n  // * Largest Acked: A variable-sized unsigned value representing the largest packet number the peer has observed.\n  // * Largest Acked Delta Time: A 16-bit unsigned float with 11 explicit bits of mantissa and 5 bits of\n  //   explicit exponent, specifying the time elapsed in microseconds from when largest acked was received until\n  //   this Ack frame was sent. The bit format is loosely modeled after IEEE 754. For example, 1 microsecond is\n  //   represented as 0x1, which has an exponent of zero, presented in the 5 high order bits, and mantissa of 1,\n  //   presented in the 11 low order bits. When the explicit exponent is greater than zero, an implicit high-order\n  //   12th bit of 1 is assumed in the mantissa. For example, a floating value of 0x800 has an explicit exponent of 1,\n  //   as well as an explicit mantissa of 0, but then has an effective mantissa of 4096 (12th bit is assumed to be 1).\n  //   Additionally, the actual exponent is one-less than the explicit exponent, and the value represents\n  //   4096 microseconds. Any values larger than the representable range are clamped to 0xFFFF.\n  // * Ack Block Section:\n  //   - Num Blocks: An optional 8-bit unsigned value specifying one less than the number of ack blocks.\n  //     Only present if the 'n' flag bit is 1.\n  //   - Ack block length: A variable-sized packet number delta. For the first missing packet range,\n  //     the ack block starts at largest acked. For the first ack block, the length of the ack block is\n  //     1 + this value.  For subsequent ack blocks, it is the length of the ack block. For non-first blocks,\n  //     a value of 0 indicates more than 256 packets in a row were lost.\n  //   - Gap to next block: An 8-bit unsigned value specifying the number of packets between ack blocks.\n  // * Timestamp Section:\n  //   - Num Timestamp: An 8-bit unsigned value specifying the number of timestamps that are included\n  //     in this ack frame. There will be this many pairs of <packet number, timestamp> following in the timestamps.\n  //   - Delta Largest Observed: An 8-bit unsigned value specifying the packet number delta from the\n  //     first timestamp to the largest observed. Therefore, the packet number is the largest observed minus\n  //     the delta largest observed.\n  //   - First Timestamp: A 32-bit unsigned value specifying the time delta in microseconds, from the beginning\n  //     of the connection of the arrival of the packet specified by Largest Observed minus Delta Largest Observed.\n  //   - Delta Largest Observed (Repeated): (Same as above.)\n  //   - Time Since Previous Timestamp (Repeated): A 16-bit unsigned value specifying delta from the previous\n  //     timestamp. It is encoded in the same format as the Ack Delay Time.\n  //\n  static fromBuffer(bufv) {\n    bufv.walk(1);\n    const type = bufv.buf[bufv.start];\n    if (!isACKType(type)) {\n      throw new error_1.QuicError('QUIC_INVALID_ACK_DATA');\n    }\n    const frame = new AckFrame();\n    const hasMissingRanges = (type & 0b00100000) > 0;\n    const missingNumberDeltaLen = protocol_1.PacketNumber.flagToByteLen(type & 0b11);\n    const largestAckedNumber = protocol_1.PacketNumber.fromBuffer(bufv, protocol_1.PacketNumber.flagToByteLen(type >> 2 & 0b11));\n    frame.largestAcked = largestAckedNumber.valueOf();\n    bufv.walk(2);\n    if (bufv.isOutside()) {\n      throw new error_1.QuicError('QUIC_INVALID_ACK_DATA');\n    }\n    frame.delayTime = common_1.readUFloat16(bufv.buf, bufv.start);\n    let numAckBlocks = 0;\n    if (hasMissingRanges) {\n      bufv.walk(1);\n      if (bufv.isOutside()) {\n        throw new error_1.QuicError('QUIC_INVALID_ACK_DATA');\n      }\n      numAckBlocks = bufv.buf.readUInt8(bufv.start);\n    }\n    if (hasMissingRanges && numAckBlocks === 0) {\n      throw new error_1.QuicError('QUIC_INVALID_ACK_DATA');\n    }\n    bufv.walk(missingNumberDeltaLen);\n    if (bufv.isOutside()) {\n      throw new error_1.QuicError('QUIC_INVALID_ACK_DATA');\n    }\n    let ackBlockLength = bufv.buf.readUIntBE(bufv.start, missingNumberDeltaLen);\n    if (frame.largestAcked > 0 && ackBlockLength < 1 || ackBlockLength > frame.largestAcked) {\n      throw new error_1.QuicError('QUIC_INVALID_ACK_DATA');\n    }\n    if (hasMissingRanges) {\n      let ackRange = new AckRange(frame.largestAcked - ackBlockLength + 1, frame.largestAcked);\n      frame.ackRanges.push(ackRange);\n      let inLongBlock = false;\n      let lastRangeComplete = false;\n      for (let i = 0; i < numAckBlocks; i++) {\n        bufv.walk(1);\n        if (bufv.isOutside()) {\n          throw new error_1.QuicError('QUIC_INVALID_ACK_DATA');\n        }\n        const gap = bufv.buf.readUInt8(bufv.start);\n        bufv.walk(missingNumberDeltaLen);\n        if (bufv.isOutside()) {\n          throw new error_1.QuicError('QUIC_INVALID_ACK_DATA');\n        }\n        ackBlockLength = bufv.buf.readUIntBE(bufv.start, missingNumberDeltaLen);\n        const lastAckRange = frame.ackRanges[frame.ackRanges.length - 1];\n        if (inLongBlock) {\n          lastAckRange.first -= gap + ackBlockLength;\n          lastAckRange.last -= gap;\n        } else {\n          lastRangeComplete = false;\n          ackRange = new AckRange(0, lastAckRange.first - gap - 1);\n          ackRange.first = ackRange.last - ackBlockLength + 1;\n          frame.ackRanges.push(ackRange);\n        }\n        if (ackBlockLength > 0) {\n          lastRangeComplete = true;\n        }\n        inLongBlock = ackBlockLength === 0;\n      }\n      // if the last range was not complete, firstNum and lastNum make no sense\n      // remove the range from frame.ackRanges\n      if (!lastRangeComplete) {\n        frame.ackRanges = frame.ackRanges.slice(0, -1);\n      }\n      frame.lowestAcked = frame.ackRanges[frame.ackRanges.length - 1].first;\n    } else {\n      if (frame.largestAcked === 0) {\n        frame.lowestAcked = 0;\n      } else {\n        frame.lowestAcked = frame.largestAcked - ackBlockLength + 1;\n      }\n    }\n    if (!frame.validateAckRanges()) {\n      throw new error_1.QuicError('QUIC_INVALID_ACK_DATA');\n    }\n    bufv.walk(1);\n    if (bufv.isOutside()) {\n      throw new error_1.QuicError('QUIC_INVALID_ACK_DATA');\n    }\n    const numTimestamp = bufv.buf.readUInt8(bufv.start);\n    if (numTimestamp > 0) {\n      // TODO\n      // Delta Largest acked\n      bufv.walk(1);\n      if (bufv.isOutside()) {\n        throw new error_1.QuicError('QUIC_INVALID_ACK_DATA');\n      }\n      // buf.readUInt8(v.start)\n      // First Timestamp\n      bufv.walk(4);\n      if (bufv.isOutside()) {\n        throw new error_1.QuicError('QUIC_INVALID_ACK_DATA');\n      }\n      // buf.readUInt32BE(v.start)\n      for (let i = 0; i < numTimestamp - 1; i++) {\n        // Delta Largest acked\n        bufv.walk(1);\n        if (bufv.isOutside()) {\n          throw new error_1.QuicError('QUIC_INVALID_ACK_DATA');\n        }\n        // buf.readUInt8(v.start)\n        // Time Since Previous Timestamp\n        bufv.walk(2);\n        if (bufv.isOutside()) {\n          throw new error_1.QuicError('QUIC_INVALID_ACK_DATA');\n        }\n        // buf.readUInt16BE(v.start)\n      }\n    }\n    return frame;\n  }\n  constructor() {\n    super(0b01000000, 'ACK');\n    this.largestAcked = 0; // largest PacketNumber Value\n    this.lowestAcked = 0; // lowest PacketNumber Value\n    // has to be ordered. The ACK range with the highest firstNum goes first,\n    // the ACK range with the lowest firstNum goes last\n    this.ackRanges = [];\n    this.delayTime = 0; // microseconds\n    // time when the LargestAcked was received, this field Will not be set for received ACKs frames\n    this.largestAckedTime = 0; // millisecond, timestamp\n  }\n  valueOf() {\n    return {\n      name: this.name,\n      type: this.type,\n      largestAcked: this.largestAcked,\n      lowestAcked: this.lowestAcked,\n      delayTime: this.delayTime,\n      ackRanges: this.ackRanges\n    };\n  }\n  hasMissingRanges() {\n    return this.ackRanges.length > 0;\n  }\n  validateAckRanges() {\n    if (this.ackRanges.length === 0) {\n      return true;\n    }\n    // if there are missing packets, there will always be at least 2 ACK ranges\n    if (this.ackRanges.length === 1) {\n      return false;\n    }\n    if (this.ackRanges[0].last !== this.largestAcked) {\n      return false;\n    }\n    // check the validity of every single ACK range\n    for (const ackRange of this.ackRanges) {\n      if (ackRange.first > ackRange.last || ackRange.first <= 0) {\n        return false;\n      }\n    }\n    // check the consistency for ACK with multiple NACK ranges\n    for (let i = 1, l = this.ackRanges.length; i < l; i++) {\n      const lastAckRange = this.ackRanges[i - 1];\n      if (lastAckRange.first <= this.ackRanges[i].first) {\n        return false;\n      }\n      if (lastAckRange.first <= this.ackRanges[i].last + 1) {\n        return false;\n      }\n    }\n    return true;\n  }\n  numWritableNackRanges() {\n    if (this.ackRanges.length === 0) {\n      return 0;\n    }\n    let numRanges = 0;\n    for (let i = 1, l = this.ackRanges.length; i < l; i++) {\n      const lastAckRange = this.ackRanges[i - 1];\n      const gap = lastAckRange.first - this.ackRanges[i].last - 1;\n      let rangeLength = 1 + Math.floor(gap / 0xff);\n      if (gap % 0xff === 0) {\n        rangeLength--;\n      }\n      if (numRanges + rangeLength < 0xff) {\n        numRanges += rangeLength;\n      } else {\n        break;\n      }\n    }\n    return numRanges + 1;\n  }\n  getMissingNumberDeltaFlagBits() {\n    let maxRangeLength = 0;\n    if (this.hasMissingRanges()) {\n      for (const ackRange of this.ackRanges) {\n        const rangeLength = ackRange.len();\n        if (rangeLength > maxRangeLength) {\n          maxRangeLength = rangeLength;\n        }\n      }\n    } else {\n      maxRangeLength = this.largestAcked - this.lowestAcked + 1;\n    }\n    if (maxRangeLength <= 0xff) {\n      return 0;\n    }\n    if (maxRangeLength <= 0xffff) {\n      return 1;\n    }\n    if (maxRangeLength <= 0xffffff) {\n      return 2;\n    }\n    return 3;\n  }\n  setDelay() {\n    this.delayTime = (Date.now() - this.largestAckedTime) * 1000; // microsecond\n  }\n  acksPacket(val) {\n    if (val < this.lowestAcked || val > this.largestAcked) {\n      return false;\n    }\n    if (this.hasMissingRanges()) {\n      // TODO: this could be implemented as a binary search\n      for (const ackRange of this.ackRanges) {\n        if (val >= ackRange.first && val <= ackRange.last) {\n          return true;\n        }\n      }\n      return false;\n    }\n    // if packet doesn't have missing ranges\n    return val >= this.lowestAcked && val <= this.largestAcked;\n  }\n  byteLen() {\n    const hasMissingRanges = this.hasMissingRanges();\n    const largestAckedNum = new protocol_1.PacketNumber(this.largestAcked);\n    const flagBits = this.getMissingNumberDeltaFlagBits();\n    const largestAckedLen = largestAckedNum.byteLen();\n    const missingNumberDeltaLen = protocol_1.PacketNumber.flagToByteLen(flagBits);\n    let frameLen = 1 + largestAckedLen + 2;\n    let numRanges = 0;\n    // Blocks\n    if (!hasMissingRanges) {\n      frameLen += missingNumberDeltaLen;\n    } else {\n      numRanges = this.numWritableNackRanges();\n      if (numRanges > 0xff) {\n        throw new Error('AckFrame: Too many ACK ranges');\n      }\n      frameLen += missingNumberDeltaLen + 1;\n      frameLen += (missingNumberDeltaLen + 1) * (numRanges - 1);\n    }\n    // Timestamps\n    return frameLen + 1;\n  }\n  writeTo(bufv) {\n    const hasMissingRanges = this.hasMissingRanges();\n    if (hasMissingRanges) {\n      this.type |= 0b100000;\n    }\n    const largestAckedNum = new protocol_1.PacketNumber(this.largestAcked);\n    this.type |= largestAckedNum.flagBits() << 2;\n    const flagBits = this.getMissingNumberDeltaFlagBits();\n    this.type |= flagBits;\n    const missingNumberDeltaLen = protocol_1.PacketNumber.flagToByteLen(flagBits);\n    let numRanges = 0;\n    bufv.walk(1);\n    bufv.buf.writeUInt8(this.type, bufv.start);\n    largestAckedNum.writeTo(bufv);\n    bufv.walk(2);\n    common_1.writeUFloat16(bufv.buf, this.delayTime, bufv.start);\n    let numRangesWritten = 0;\n    if (hasMissingRanges) {\n      numRanges = this.numWritableNackRanges();\n      if (numRanges > 0xff) {\n        throw new error_1.QuicError('AckFrame: Too many ACK ranges');\n      }\n      bufv.walk(1);\n      bufv.buf.writeUInt8(numRanges - 1, bufv.start);\n    }\n    let firstAckBlockLength = 0;\n    if (!hasMissingRanges) {\n      firstAckBlockLength = this.largestAcked - this.lowestAcked + 1;\n    } else {\n      if (this.largestAcked !== this.ackRanges[0].last) {\n        throw new error_1.QuicError('AckFrame: largestAcked does not match ACK ranges');\n      }\n      if (this.lowestAcked !== this.ackRanges[this.ackRanges.length - 1].first) {\n        throw new error_1.QuicError('AckFrame: lowestAcked does not match ACK ranges');\n      }\n      firstAckBlockLength = this.largestAcked - this.ackRanges[0].first + 1;\n      numRangesWritten++;\n    }\n    bufv.walk(missingNumberDeltaLen);\n    bufv.buf.writeUIntBE(firstAckBlockLength, bufv.start, missingNumberDeltaLen);\n    for (let i = 1, l = this.ackRanges.length; i < l; i++) {\n      const length = this.ackRanges[i].len();\n      const gap = this.ackRanges[i - 1].first - this.ackRanges[i].last - 1;\n      let num = Math.floor(gap / 0xff) + 1;\n      if (gap % 0xff === 0) {\n        num--;\n      }\n      if (num === 1) {\n        bufv.walk(1);\n        bufv.buf.writeUInt8(gap, bufv.start);\n        bufv.walk(missingNumberDeltaLen);\n        bufv.buf.writeUIntBE(length, bufv.start, missingNumberDeltaLen);\n        numRangesWritten++;\n      } else {\n        for (let j = 0; j < num; j++) {\n          let lengthWritten = 0;\n          let gapWritten = 0;\n          if (j === num - 1) {\n            // last block\n            lengthWritten = length;\n            gapWritten = 1 + (gap - 1) % 255;\n          } else {\n            lengthWritten = 0;\n            gapWritten = 0xff;\n          }\n          bufv.walk(1);\n          bufv.buf.writeUInt8(gapWritten, bufv.start);\n          bufv.walk(missingNumberDeltaLen);\n          bufv.buf.writeUIntBE(lengthWritten, bufv.start, missingNumberDeltaLen);\n          numRangesWritten++;\n        }\n      }\n      // this is needed if not all AckRanges can be written to the ACK frame (if there are more than 0xFF)\n      if (numRangesWritten >= numRanges) {\n        break;\n      }\n    }\n    if (numRanges !== numRangesWritten) {\n      throw new error_1.QuicError('AckFrame: Inconsistent number of ACK ranges written');\n    }\n    bufv.walk(1);\n    bufv.buf.writeUInt8(0, bufv.start); // no timestamps\n    return bufv;\n  }\n}\nexports.AckFrame = AckFrame;\n/** StopWaitingFrame representing a QUIC STOP_WAITING frame. */\nclass StopWaitingFrame extends Frame {\n  // STOP_WAITING Frame\n  //\n  // --- src\n  //      0        1        2        3         4       5       6\n  // +--------+--------+--------+--------+--------+-------+-------+\n  // |Type (8)|   Least unacked delta (8, 16, 32, or 48 bits)     |\n  // |        |                       (variable length)           |\n  // +--------+--------+--------+--------+--------+--------+------+\n  // ---\n  //\n  // The fields in the STOP_WAITING frame are as follows:\n  // * Frame Type: The Frame Type byte is an 8-bit value that must be set to 0x06 indicating\n  //   that this is a STOP_WAITING frame.\n  // * Least Unacked Delta: A variable length packet number delta with the same length as the\n  //   packet header's packet number.  Subtract it from the header's packet number to determine\n  //   the least unacked. The resulting least unacked is the smallest packet number of any packet\n  //   for which the sender is still awaiting an ack. If the receiver is missing any packets smaller\n  //   than this value, the receiver should consider those packets to be irrecoverably lost.\n  //\n  static fromBuffer(bufv, packetNumber) {\n    bufv.walk(1);\n    const type = bufv.buf[bufv.start];\n    if (type !== 0x06) {\n      throw new error_1.QuicError('QUIC_INVALID_STOP_WAITING_DATA');\n    }\n    const len = packetNumber.byteLen();\n    bufv.walk(len);\n    if (bufv.isOutside()) {\n      throw new error_1.QuicError('QUIC_INVALID_STOP_WAITING_DATA');\n    }\n    const delta = bufv.buf.readIntBE(bufv.start, len, false);\n    return new StopWaitingFrame(packetNumber, packetNumber.valueOf() - delta);\n  }\n  constructor(packetNumber, leastUnacked) {\n    super(0x06, 'STOP_WAITING');\n    this.packetNumber = packetNumber; // packetNumber.valueOf() > leastUnacked\n    this.leastUnacked = leastUnacked;\n  }\n  valueOf() {\n    return {\n      name: this.name,\n      type: this.type,\n      packetNumber: this.packetNumber.valueOf(),\n      leastUnacked: this.leastUnacked\n    };\n  }\n  byteLen() {\n    return 1 + this.packetNumber.byteLen();\n  }\n  writeTo(bufv) {\n    const len = this.packetNumber.byteLen();\n    bufv.walk(1);\n    bufv.buf.writeUInt8(this.type, bufv.start);\n    bufv.walk(len);\n    bufv.buf.writeUIntBE(this.packetNumber.valueOf() - this.leastUnacked, bufv.start, len);\n    return bufv;\n  }\n}\nexports.StopWaitingFrame = StopWaitingFrame;\n/** WindowUpdateFrame representing a QUIC WINDOW_UPDATE frame. */\nclass WindowUpdateFrame extends Frame {\n  // WINDOW_UPDATE Frame\n  //\n  // --- src\n  //     0         1                 4        5                 12\n  // +--------+--------+-- ... --+-------+--------+-- ... --+-------+\n  // |Type(8) |    Stream ID (32 bits)   |  Byte offset (64 bits)   |\n  // +--------+--------+-- ... --+-------+--------+-- ... --+-------+\n  // ---\n  // The fields in the WINDOW_UPDATE frame are as follows:\n  // * Frame Type: The Frame Type byte is an 8-bit value that must be set to 0x04\n  //   indicating that this is a WINDOW_UPDATE frame.\n  // * Stream ID: ID of the stream whose flow control windows is being updated,\n  //   or 0 to specify the connection-level flow control window.\n  // * Byte offset: A 64-bit unsigned integer indicating the absolute byte offset of data\n  //   which can be sent on the given stream. In the case of connection level flow control,\n  //   the cumulative number of bytes which can be sent on all currently open streams.\n  //\n  static fromBuffer(bufv) {\n    bufv.walk(1);\n    const type = bufv.buf[bufv.start];\n    if (type !== 0x04) {\n      throw new error_1.QuicError('QUIC_INVALID_WINDOW_UPDATE_DATA');\n    }\n    const streamID = protocol_1.StreamID.fromBuffer(bufv, 4);\n    const offset = protocol_1.Offset.fromBuffer(bufv, 8);\n    return new WindowUpdateFrame(streamID, offset);\n  }\n  constructor(streamID, offset) {\n    super(0x04, 'WINDOW_UPDATE');\n    this.streamID = streamID;\n    this.offset = offset;\n  }\n  valueOf() {\n    return {\n      name: this.name,\n      type: this.type,\n      streamID: this.streamID.valueOf(),\n      offset: this.offset.valueOf()\n    };\n  }\n  byteLen() {\n    return 13;\n  }\n  writeTo(bufv) {\n    bufv.walk(1);\n    bufv.buf.writeUInt8(this.type, bufv.start);\n    this.streamID.writeTo(bufv, true);\n    this.offset.writeTo(bufv, true);\n    return bufv;\n  }\n}\nexports.WindowUpdateFrame = WindowUpdateFrame;\n/** BlockedFrame representing a QUIC BLOCKED frame. */\nclass BlockedFrame extends Frame {\n  // BLOCKED Frame\n  //\n  // --- src\n  //      0        1        2        3         4\n  // +--------+--------+--------+--------+--------+\n  // |Type(8) |          Stream ID (32 bits)      |\n  // +--------+--------+--------+--------+--------+\n  // ---\n  //\n  // The fields in the BLOCKED frame are as follows:\n  // * Frame Type: The Frame Type byte is an 8-bit value that must be set\n  //   to 0x05 indicating that this is a BLOCKED frame.\n  // * Stream ID: A 32-bit unsigned number indicating the stream which is flow control blocked.\n  //   A non-zero Stream ID field specifies the stream that is flow control blocked. When zero,\n  //   the Stream ID field indicates that the connection is flow control blocked at the connection level.\n  //\n  static fromBuffer(bufv) {\n    bufv.walk(1);\n    const type = bufv.buf[bufv.start];\n    if (type !== 0x05) {\n      throw new error_1.QuicError('QUIC_INVALID_BLOCKED_DATA');\n    }\n    const streamID = protocol_1.StreamID.fromBuffer(bufv, 4);\n    return new BlockedFrame(streamID);\n  }\n  constructor(streamID) {\n    super(0x05, 'BLOCKED');\n    this.streamID = streamID;\n  }\n  valueOf() {\n    return {\n      name: this.name,\n      type: this.type,\n      streamID: this.streamID.valueOf()\n    };\n  }\n  byteLen() {\n    return 5;\n  }\n  writeTo(bufv) {\n    bufv.walk(1);\n    bufv.buf.writeUInt8(this.type, bufv.start);\n    this.streamID.writeTo(bufv, true);\n    return bufv;\n  }\n}\nexports.BlockedFrame = BlockedFrame;\n/** CongestionFeedbackFrame representing a QUIC CONGESTION_FEEDBACK frame. */\nclass CongestionFeedbackFrame extends Frame {\n  // CONGESTION_FEEDBACK Frame\n  // The CONGESTION_FEEDBACK frame is an experimental frame currently not used.\n  // It is intended to provide extra congestion feedback information outside the scope of\n  // the standard ack frame. A CONGESTION_FEEDBACK frame must have the first three bits of\n  // the Frame Type set to 001. The last 5 bits of the Frame Type field are reserved for future use.\n  static fromBuffer(bufv) {\n    bufv.walk(1);\n    const type = bufv.buf[bufv.start];\n    if (!isCongestionType(type)) {\n      throw new error_1.QuicError('QUIC_INVALID_FRAME_DATA');\n    }\n    return new CongestionFeedbackFrame();\n  }\n  constructor() {\n    super(0b00100000, 'CONGESTION_FEEDBACK');\n  }\n  byteLen() {\n    return 1;\n  }\n  writeTo(bufv) {\n    bufv.walk(1);\n    bufv.buf.writeUInt8(this.type, bufv.start);\n    return bufv;\n  }\n}\nexports.CongestionFeedbackFrame = CongestionFeedbackFrame;\n/** PaddingFrame representing a QUIC PADDING frame. */\nclass PaddingFrame extends Frame {\n  // PADDING Frame\n  // The PADDING frame pads a packet with 0x00 bytes. When this frame is encountered,\n  // the rest of the packet is expected to be padding bytes. The frame contains 0x00 bytes\n  // and extends to the end of the QUIC packet. A PADDING frame only has a Frame Type field,\n  // and must have the 8-bit Frame Type field set to 0x00.\n  static fromBuffer(bufv) {\n    bufv.walk(1);\n    const type = bufv.buf[bufv.start];\n    if (type > 0) {\n      throw new error_1.QuicError('QUIC_INVALID_FRAME_DATA');\n    }\n    return new PaddingFrame();\n  }\n  constructor() {\n    super(0x00, 'PADDING');\n  }\n  byteLen() {\n    return 1;\n  }\n  writeTo(bufv) {\n    bufv.walk(1);\n    bufv.buf.writeUInt8(0, bufv.start);\n    return bufv;\n  }\n}\nexports.PaddingFrame = PaddingFrame;\n/** RstStreamFrame representing a QUIC RST_STREAM frame. */\nclass RstStreamFrame extends Frame {\n  // RST_STREAM Frame\n  //\n  // --- src\n  //      0        1            4      5              12     8             16\n  // +-------+--------+-- ... ----+--------+-- ... ------+-------+-- ... ------+\n  // |Type(8)| StreamID (32 bits) | Byte offset (64 bits)| Error code (32 bits)|\n  // +-------+--------+-- ... ----+--------+-- ... ------+-------+-- ... ------+\n  // ---\n  //\n  // The fields in a RST_STREAM frame are as follows:\n  // * Frame type: The Frame Type is an 8-bit value that must be set to 0x01 specifying that this is a RST_STREAM frame.\n  // * Stream ID: The 32-bit Stream ID of the stream being terminated.\n  // * Byte offset: A 64-bit unsigned integer indicating the absolute byte offset of the end of data for this stream.\n  // * Error code: A 32-bit QuicErrorCode which indicates why the stream is being closed.\n  //   QuicErrorCodes are listed later in this document.\n  //\n  static fromBuffer(bufv) {\n    bufv.walk(1);\n    const type = bufv.buf[bufv.start];\n    if (type !== 0x01 || bufv.length < bufv.end + 16) {\n      throw new error_1.QuicError('QUIC_INVALID_RST_STREAM_DATA');\n    }\n    const streamID = protocol_1.StreamID.fromBuffer(bufv, 4);\n    const offset = protocol_1.Offset.fromBuffer(bufv, 8);\n    const error = error_1.QuicError.fromBuffer(bufv);\n    return new RstStreamFrame(streamID, offset, error);\n  }\n  constructor(streamID, offset, error) {\n    super(0x01, 'RST_STREAM');\n    this.streamID = streamID;\n    this.offset = offset;\n    this.error = error;\n  }\n  valueOf() {\n    return {\n      name: this.name,\n      type: this.type,\n      streamID: this.streamID.valueOf(),\n      offset: this.offset.valueOf(),\n      error: this.error.valueOf()\n    };\n  }\n  byteLen() {\n    return 17;\n  }\n  writeTo(bufv) {\n    bufv.walk(1);\n    bufv.buf.writeUInt8(this.type, bufv.start);\n    this.streamID.writeTo(bufv, true);\n    this.offset.writeTo(bufv, true);\n    this.error.writeTo(bufv);\n    return bufv;\n  }\n}\nexports.RstStreamFrame = RstStreamFrame;\n/** PingFrame representing a QUIC PING frame. */\nclass PingFrame extends Frame {\n  // PING frame\n  // The PING frame can be used by an endpoint to verify that\n  // a peer is still alive. The PING frame contains no payload.\n  // The receiver of a PING frame simply needs to ACK the packet containing this frame.\n  // The PING frame should be used to keep a connection alive when a stream is open.\n  // The default is to do this after 15 seconds of quiescence,\n  // which is much shorter than most NATs time out. A PING frame only\n  // has a Frame Type field, and must have the 8-bit Frame Type field set to 0x07.\n  static fromBuffer(bufv) {\n    bufv.walk(1);\n    const type = bufv.buf[bufv.start];\n    if (type !== 0x07) {\n      throw new error_1.QuicError('QUIC_INVALID_FRAME_DATA');\n    }\n    return new PingFrame();\n  }\n  constructor() {\n    super(0x07, 'PING');\n  }\n  byteLen() {\n    return 1;\n  }\n  writeTo(bufv) {\n    bufv.walk(1);\n    bufv.buf.writeUInt8(this.type, bufv.start);\n    return bufv;\n  }\n}\nexports.PingFrame = PingFrame;\n/** ConnectionCloseFrame representing a QUIC CONNECTION_CLOSE frame. */\nclass ConnectionCloseFrame extends Frame {\n  // CONNECTION_CLOSE frame\n  //\n  // --- src\n  //      0        1             4        5        6       7\n  // +--------+--------+-- ... -----+--------+--------+--------+----- ...\n  // |Type(8) | Error code (32 bits)| Reason phrase   |  Reason phrase\n  // |        |                     | length (16 bits)|(variable length)\n  // +--------+--------+-- ... -----+--------+--------+--------+----- ...\n  // ---\n  //\n  // The fields of a CONNECTION_CLOSE frame are as follows:\n  // * Frame Type: An 8-bit value that must be set to 0x02 specifying that this is a CONNECTION_CLOSE frame.\n  // * Error Code: A 32-bit field containing the QuicErrorCode which indicates the reason for closing this connection.\n  // * Reason Phrase Length: A 16-bit unsigned number specifying the length of the reason phrase.\n  //   This may be zero if the sender chooses to not give details beyond the QuicErrorCode.\n  // * Reason Phrase: An optional human-readable explanation for why the connection was closed.\n  //\n  static fromBuffer(bufv) {\n    bufv.walk(1);\n    const type = bufv.buf[bufv.start];\n    if (type !== 0x02 || bufv.length < bufv.end + 6) {\n      throw new error_1.QuicError('QUIC_INVALID_CONNECTION_CLOSE_DATA');\n    }\n    const error = error_1.QuicError.fromBuffer(bufv);\n    bufv.walk(2);\n    const reasonPhraseLen = bufv.buf.readUInt16BE(bufv.start);\n    if (reasonPhraseLen > 0) {\n      bufv.walk(reasonPhraseLen);\n      if (bufv.isOutside()) {\n        throw new error_1.QuicError('QUIC_INVALID_CONNECTION_CLOSE_DATA');\n      }\n      error.message = bufv.buf.toString('utf8', bufv.start, bufv.end);\n    }\n    return new ConnectionCloseFrame(error);\n  }\n  constructor(error) {\n    super(0x02, 'CONNECTION_CLOSE');\n    this.error = error;\n  }\n  valueOf() {\n    return {\n      name: this.name,\n      type: this.type,\n      error: this.error.valueOf()\n    };\n  }\n  byteLen() {\n    const reasonPhrase = this.error.message;\n    const reasonPhraseLen = reasonPhrase !== '' ? Buffer.byteLength(reasonPhrase) : 0;\n    return 7 + reasonPhraseLen;\n  }\n  writeTo(bufv) {\n    const reasonPhrase = this.error.message;\n    const reasonPhraseLen = reasonPhrase !== '' ? Buffer.byteLength(reasonPhrase) : 0;\n    bufv.walk(1);\n    bufv.buf.writeUInt8(this.type, bufv.start);\n    this.error.writeTo(bufv);\n    bufv.walk(2);\n    bufv.buf.writeUInt16BE(reasonPhraseLen, bufv.start);\n    if (reasonPhrase !== '') {\n      bufv.walk(reasonPhraseLen);\n      bufv.buf.write(reasonPhrase, bufv.start, reasonPhraseLen);\n    }\n    return bufv;\n  }\n}\nexports.ConnectionCloseFrame = ConnectionCloseFrame;\n/** GoAwayFrame representing a QUIC GOAWAY frame. */\nclass GoAwayFrame extends Frame {\n  // GOAWAY Frame\n  //\n  // --- src\n  //      0        1             4      5       6       7      8\n  // +--------+--------+-- ... -----+-------+-------+-------+------+\n  // |Type(8) | Error code (32 bits)| Last Good Stream ID (32 bits)| ->\n  // +--------+--------+-- ... -----+-------+-------+-------+------+\n  //\n  //       9        10       11\n  // +--------+--------+--------+----- ...\n  // | Reason phrase   |  Reason phrase\n  // | length (16 bits)|(variable length)\n  // +--------+--------+--------+----- ...\n  // ---\n  //\n  // The fields of a GOAWAY frame are as follows:\n  // * Frame type: An 8-bit value that must be set to 0x03 specifying that this is a GOAWAY frame.\n  // * Error Code: A 32-bit field containing the QuicErrorCode which indicates the reason for closing this connection.\n  // * Last Good Stream ID: The last Stream ID which was accepted by the sender of the GOAWAY message.\n  //   If no streams were replied to, this value must be set to 0.\n  // * Reason Phrase Length: A 16-bit unsigned number specifying the length of the reason phrase.\n  //   This may be zero if the sender chooses to not give details beyond the error code.\n  // * Reason Phrase: An optional human-readable explanation for why the connection was closed.\n  //\n  static fromBuffer(bufv) {\n    bufv.walk(1);\n    const type = bufv.buf[bufv.start];\n    if (type !== 0x03) {\n      throw new error_1.QuicError('QUIC_INVALID_GOAWAY_DATA');\n    }\n    const error = error_1.QuicError.fromBuffer(bufv);\n    const streamID = protocol_1.StreamID.fromBuffer(bufv, 4);\n    bufv.walk(2);\n    if (bufv.isOutside()) {\n      throw new error_1.QuicError('QUIC_INVALID_GOAWAY_DATA');\n    }\n    const reasonPhraseLen = bufv.buf.readUInt16BE(bufv.start);\n    if (reasonPhraseLen > 0) {\n      bufv.walk(reasonPhraseLen);\n      if (bufv.isOutside()) {\n        throw new error_1.QuicError('QUIC_INVALID_GOAWAY_DATA');\n      }\n      error.message = bufv.buf.toString('utf8', bufv.start, bufv.end);\n    }\n    return new GoAwayFrame(streamID, error);\n  }\n  constructor(lastGoodStreamID, error) {\n    super(0x03, 'GOAWAY');\n    this.streamID = lastGoodStreamID;\n    this.error = error;\n  }\n  valueOf() {\n    return {\n      name: this.name,\n      type: this.type,\n      streamID: this.streamID.valueOf(),\n      error: this.error.valueOf()\n    };\n  }\n  byteLen() {\n    const reasonPhrase = this.error.message;\n    const reasonPhraseLen = reasonPhrase !== '' ? Buffer.byteLength(reasonPhrase) : 0;\n    return 11 + reasonPhraseLen;\n  }\n  writeTo(bufv) {\n    const reasonPhrase = this.error.message;\n    const reasonPhraseLen = reasonPhrase !== '' ? Buffer.byteLength(reasonPhrase) : 0;\n    bufv.walk(1);\n    bufv.buf.writeUInt8(this.type, bufv.start);\n    this.error.writeTo(bufv);\n    this.streamID.writeTo(bufv, true);\n    bufv.walk(2);\n    bufv.buf.writeUInt16BE(reasonPhraseLen, bufv.start);\n    if (reasonPhrase !== '') {\n      bufv.walk(reasonPhraseLen);\n      bufv.buf.write(reasonPhrase, bufv.start, reasonPhraseLen);\n    }\n    return bufv;\n  }\n}\nexports.GoAwayFrame = GoAwayFrame;","map":{"version":3,"names":["util_1","require","error_1","protocol_1","common_1","isCongestionType","flag","exports","isACKType","isStreamType","parseFrame","bufv","headerPacketNumber","walk","type","buf","readUInt8","start","StreamFrame","fromBuffer","AckFrame","CongestionFeedbackFrame","PaddingFrame","RstStreamFrame","ConnectionCloseFrame","GoAwayFrame","WindowUpdateFrame","BlockedFrame","StopWaitingFrame","PingFrame","QuicError","Frame","_bufv","_headerPacketNumber","Error","constructor","name","valueOf","toString","JSON","stringify","isRetransmittable","inspect","custom","_depth","_options","isFIN","streamID","StreamID","flagToByteLen","offset","Offset","data","isOutside","len","readUInt16BE","Buffer","allocUnsafe","copy","end","length","frame","setData","headerLen","hasDataLen","byteLen","dataLen","writeTo","flagBits","writeUInt8","writeUInt16BE","AckRange","firstPacketNumberValue","lastPacketNumberValue","last","first","hasMissingRanges","missingNumberDeltaLen","PacketNumber","largestAckedNumber","largestAcked","delayTime","readUFloat16","numAckBlocks","ackBlockLength","readUIntBE","ackRange","ackRanges","push","inLongBlock","lastRangeComplete","i","gap","lastAckRange","slice","lowestAcked","validateAckRanges","numTimestamp","largestAckedTime","l","numWritableNackRanges","numRanges","rangeLength","Math","floor","getMissingNumberDeltaFlagBits","maxRangeLength","setDelay","Date","now","acksPacket","val","largestAckedNum","largestAckedLen","frameLen","writeUFloat16","numRangesWritten","firstAckBlockLength","writeUIntBE","num","j","lengthWritten","gapWritten","packetNumber","delta","readIntBE","leastUnacked","error","reasonPhraseLen","message","reasonPhrase","byteLength","write","lastGoodStreamID"],"sources":["../../src/internal/frame.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}